/**
 *                             Vortex Cafe
 *
 *    This software and documentation are Copyright 2010 to 2019 ADLINK
 *    Technology Limited, its affiliated companies and licensors. All rights
 *    reserved.
 *
 *    Licensed under the ADLINK Software License Agreement Rev 2.7 2nd October
 *    2014 (the "License"); you may not use this file except in compliance with
 *    the License.
 *    You may obtain a copy of the License at:
 *                        docs/LICENSE.html
 *
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.eclipse.cyclonedds.idl2j;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.text.DateFormat;
import java.util.Collection;
import java.util.Date;

import org.apache.maven.plugin.logging.Log;
import org.apache.maven.plugin.logging.SystemStreamLog;

import org.eclipse.cyclonedds.idl2j.KeyListDescriptor;
import org.eclipse.cyclonedds.idl2j.KeyListParser;

import java.io.File;
import java.io.FilenameFilter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;


public class Compiler
{

   // Maven logger
   private Log log;

   // arguments
   private String[] args;

   // destination directory
   private String destDir;

   // verbose mode
   private boolean verbose;

   // default package prefix
   private String defaultPkgPrefix;

   // default constructor (uses SystemStreamLog as Maven logger)
   protected Compiler()
   {
      this(new SystemStreamLog());
   }

   // constructor called by Mojo
   protected Compiler(Log log)
   {
      this.log = log;
      this.destDir = "";
      this.verbose = false;
      this.defaultPkgPrefix = "";
   }

   // parse arguments
   protected void parseArgs(String[] args) throws Exception
   {
      this.args = args;

      // get destination dir and verbose arguments
      for (int i = 0; i < args.length; ++i)
      {
         if (args[i].equals("-td"))
         {
            destDir = args[ ++i] + File.separator;
         }
         if (args[i].equals("-defaultPkgPrefix"))
         {
            defaultPkgPrefix = args[ ++i];
         }
         if (args[i].equals("-v") || args[i].equals("-verbose"))
         {
            verbose = true;
         }
      }
   }

   // run JDK's idlj
   protected void runIdlj() throws Exception
   {
      List<String> idljArgs = new ArrayList<String>();
      if (verbose)
      {
         log.info("Running idlj compiler : ");
      }
      StringBuffer cmdLine = new StringBuffer();
      for (String arg : args)
      {
         if ( !arg.equals("-defaultPkgPrefix") && !arg.equals(defaultPkgPrefix))
         {
            cmdLine.append(arg + " ");
            idljArgs.add(arg);
         }
      }
      if (verbose)
      {
         log.info(cmdLine);
      }
      String[] result = new String[idljArgs.size()];
      ProcessBuilder pb = new ProcessBuilder(idljArgs.toArray(result));
      Process idljProc = null;
      int exitStatus = 1;
      boolean errorOccured = false;
      try
      {
         // start idlj process
         idljProc = pb.start();

         // consume outputs lines separate threads to avoid blocking situation
         // in case the OS redirection buffer in full (typically on Windows...)
         StdoutGobbler outGobbler = new StdoutGobbler(idljProc.getInputStream(), log);
         StderrGobbler errGobbler = new StderrGobbler(idljProc.getErrorStream(), log);
         outGobbler.start();
         errGobbler.start();

         // wait for process end
         exitStatus = idljProc.waitFor();

         outGobbler.close();
         errGobbler.close();

         // check if some error were printed
         // (it happens that idlj returns 0 as exit code despite of errors...)
         errorOccured = errGobbler.wasErrorPrinted();

      }
      catch (Throwable t)
      {
         if (verbose)
         {
            t.printStackTrace();
         }
         throw new Exception("Error running idlj: " + t.getMessage());
      }
      finally
      {
         if (idljProc != null)
         {
            idljProc.destroy();
         }
      }

      if (exitStatus != 0)
      {
         throw new Exception("Error running idlj: exit status is " + idljProc.exitValue());
      }
      if (errorOccured)
      {
         throw new Exception("Error running idlj: see above error logs");
      }

      if (verbose)
      {
         log.info("  Done.");
      }
   }

   // patch code generated by idlj
   protected void patchGeneratedCode() throws Exception
   {

      String idlFile = args[args.length - 1];

      try
      {
         if (verbose)
         {
            log.info("Parsing : " + idlFile);
         }

         Collection<KeyListDescriptor> keyLists = KeyListParser.jparse(idlFile);
         if (verbose)
         {
            System.out.println("  Done.");
         }

         for (KeyListDescriptor keyList : keyLists)
         {
            String[] elements = keyList.typeName().split("\\.");
            String className = elements[elements.length - 1];
            String javaFile = destDir + keyList.typeName().replace('.', '/') + ".java";
            if (verbose)
            {
               System.out.println("Updating : " + javaFile);
            }
            try
            {
               StringBuilder buf = new StringBuilder();
               BufferedReader in = new BufferedReader(new FileReader(javaFile));

               try
               {
                  String line = in.readLine();
                  while (line != null)
                  {
                     if (line.contains("public final class " + className))
                     {
                        line = line.replace("final class " + className, "class " + className + " extends Structure");
                    	 buf.append("/**\n");
                        buf.append("* Updated by idl2j\n");
                        buf.append("* from ").append(idlFile).append("\n");
                        buf.append("* ")
                              .append(
                                    DateFormat
                                          .getDateTimeInstance(DateFormat.FULL, DateFormat.FULL)
                                          .format(new Date()))
                              .append("\n");
                        buf.append("*/\n");
                        buf.append("\n");
                        // for JNA
                        buf.append("import java.util.Arrays;\n");
                        buf.append("import java.util.List;\n");
                        buf.append("import com.sun.jna.Pointer;\n");
                        buf.append("import com.sun.jna.Structure;\n");
                        //
                        buf.append("import org.eclipse.cyclonedds.dcps.keys.KeyList;");
                        buf.append("\n");
                        buf.append("\n");
                        buf.append("@KeyList(\n");
                        buf.append("    topicType = \"")
                              .append(className).append("\",\n");
                        if ( !keyList.keyList().isEmpty())
                        {
                           buf.append("    keys = {\"")
                                 .append(keyList.keyList().replace(", ", "\", \""))
                                 .append("\"}\n");
                        }
                        else
                        {
                           buf.append("    keys = {}\n");
                        }
                        buf.append(")\n");
                        buf.append(line).append("\n");
                        line = in.readLine();
                     }
                     // JNA
                      if (line.contains("public " + className + " ("))
                      {
                         buf.append(line).append("\n");
                         line = in.readLine(); // {
                         buf.append(line).append("\n");
                         buf.append("\tsuper();\n");
                         line = in.readLine(); // {
                      }
                      if (line.contains("} // class " + className))
                      {
                         buf.append("\tprotected List<String> getFieldOrder() {\n");
                         buf.append("\t\treturn Arrays.asList(\"userID\", \"message\");\n");  // TODO retrieve the fields from idl file or maybe from .h generated by idlc
                         buf.append("\t}\n");
                         // TODO retrieve the topic name (here HelloWorldData_Msg) from idl file or maybe from .h generated by idlc
                         buf.append("\tpublic "+className+"(Pointer peer) {\n\t\tsuper(peer);\n\t}\n");
                         buf.append("\tpublic static class ByReference extends "+className+" implements Structure.ByReference {};\n");
                         buf.append("\tpublic static class ByValue extends "+className+" implements Structure.ByValue {};\n");
                         // end TODO retrieve the topic name (here HelloWorldData_Msg) from idl file or maybe from .h generated by idlc
                      }
                     buf.append(line).append("\n");
                     line = in.readLine();
                  }
                  in.close();

                  BufferedWriter out = new BufferedWriter(new OutputStreamWriter(
                        new FileOutputStream(javaFile), "UTF-8"));
                  try
                  {
                     out.write(buf.toString());
                  }
                  finally
                  {
                     out.close();
                  }
               }
               finally
               {
                  in.close();
               }
            }
            catch (IOException e)
            {
               System.err.println("[ERROR] Unable to update file " + javaFile);
               e.printStackTrace();
            }

            if (verbose)
            {
               log.info("  Done.");
            }
         }
      }
      catch (Throwable t)
      {
         if (verbose)
         {
            t.printStackTrace();
         }
         throw new Exception("Error patching code generated for "
               + idlFile + ": " + t.getMessage());
      }
   }

   // patch code generated by idlj
   protected void patchNonScopedGeneratedCode() throws Exception
   {
      if (verbose)
      {
         log.info("Moving files from default package to " + defaultPkgPrefix + " package");
      }

      // find all *.java files in the destDir directory (no recursive search)
      String[] dir = new java.io.File(destDir).list(
            new FilenameFilter()
            {

               @Override
               public boolean accept(File dir, String name)
               {
                  return name.endsWith(".java");
               }
            }
            );

      // create directories for package "defaultPkgPrefix"
      File defaultDir = new File(destDir + File.separator
            + defaultPkgPrefix.replace('.', File.separatorChar));
      if ( !defaultDir.exists() && !defaultDir.mkdirs())
      {
         System.err.println("[ERROR] Unable to create directory: " + defaultDir);
      }

      // copy each java file to its new package directory,
      // adding the package declaration within
      for (int i = 0; i < dir.length; i++)
      {
         if (verbose)
         {
            log.info("  moving " + dir[i]);
         }
         Path in = Paths.get(destDir + File.separator + dir[i]);
         List<String> lines = Files.readAllLines(in, StandardCharsets.UTF_8);
         lines.add(0, "package " + defaultPkgPrefix + ";");
         Path out = Paths.get(defaultDir + File.separator + dir[i]);
         Files.write(out, lines, StandardCharsets.UTF_8);
         Files.delete(in);
      }
   }

   /**
    * Invoke the idl compiler for the given IDL File
    *
    * @param arguments command line to be passed to idlj
    */
   public static void main(String[] args)
   {

      try
      {
         // add idlj command as first argument
         String[] processArgs = new String[args.length + 1];
         processArgs[0] = "idlj";
         System.arraycopy(args, 0, processArgs, 1, args.length);

         // start Compiler
         Compiler compiler = new Compiler();
         compiler.parseArgs(processArgs);
         compiler.runIdlj();
         compiler.patchGeneratedCode();
         if ( !compiler.defaultPkgPrefix.isEmpty())
         {
            compiler.patchNonScopedGeneratedCode();
         }
      }
      catch (Throwable t)
      {
         System.err.println(t.getMessage());
         System.exit(1);
      }
   }
}
